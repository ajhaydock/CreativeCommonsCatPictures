# nginx.conf for the Docker container hosting creativecommonscatpictures.com

# Based on the default nginx config file with some tweaks to
# secure an .onion domain pointing directly at this server.

#user			nginx; # This user is named 'nginx' on Red Hat family distributions like CentOS and 'www-data' on Debian-based distributions.
worker_processes	1;

error_log		/var/log/nginx/error.log warn;
pid			/var/run/nginx.pid; # Set for Fedora. Probably in a different place on Debian.

events {
	worker_connections  1024;
}

http {
	access_log			/dev/null; # Anonymised logging is handled by my SSL terminator instead of at Docker container endpoints.

	# Various options
	charset				utf-8;
	default_type			application/octet-stream;
	ignore_invalid_headers		on;
	include				/etc/nginx/conf.d/*.conf;
	include				/etc/nginx/mime.types;
	keepalive_requests		50;  # Number of requests per connection (does not affect SPDY)
	keepalive_disable		none; # Allow all browsers to use keepalive connections
	max_ranges			1; # Only allow a single range header - for resumed downloads, and to stop large range header DoS attacks
	open_file_cache			max=1000 inactive=2h;
	open_file_cache_errors		on;
	open_file_cache_min_uses	1;
	open_file_cache_valid		1h;
	output_buffers			1 512; # Use one 512k chunk output buffer (only if sendfile is off)
	read_ahead			512K; # Kernel read head set to the output_buffers
	recursive_error_pages		on;
	reset_timedout_connection	on; # Reset timed out connections to free RAM
	sendfile			on;  # On for decent direct disk I/O
	server_tokens			off; # Version number in error pages
	server_name_in_redirect		off; # If off, nginx will use the requested Host header
	source_charset			utf-8; # Same value as "charset"
	tcp_nodelay			on; # Nagle buffering algorithm, used for keepalive only
	tcp_nopush			off;

	# Compression Options
	gzip				on;
	gzip_buffers			4 32k; # Set the buffer size of gzip, 4 32k is good enough for almost everybody. (Well, according to the tutorial I copied this line from...)
	gzip_proxied			any; # Allows compressed responses for any request even from proxies
	gzip_types			text/html
					text/css
					text/xml
					application/javascript
					application/atom+xml
					application/rss+xml
					text/plain
					application/font-woff
					application/json
					application/pdf
					application/x-x509-ca-cert
					application/xhtml+xml
					application/xspf+xml; # Here I just copied in all of the MIME types that looked compressible from /etc/nginx/mime.types (leaving out ones I will clearly never use)
	gzip_vary			on; # Enables response header of "Vary: Accept-Encoding

	# Manage standard headers
	add_header		X-Frame-Options "DENY"; # Disallow the site from being loaded in an IFRAME. Being deprecated in favour of CSP's frame-ancestors directive: https://appsec-labs.com/portal/anti-clickjacking/
	add_header		X-Content-Type-Options nosniff;
	add_header		X-XSS-Protection "1; mode=block";
	add_header		Cache-Control "public";

	# Manage CSP header (https://wiki.mozilla.org/Security/CSP/Specification)
	## This policy will block basically all scripts, plugins, child frames (YouTube embeds etc.) and will need reviewing if I ever start using those but, for now, this is going to be pretty secure.
	## I usually add this at SSL-terminator level, but I'm putting this in here in case I start serving the site via Tor hidden service.
	add_header		Content-Security-Policy "frame-ancestors 'none'; default-src 'none'; font-src 'self'; img-src 'self'; media-src 'self'; style-src 'self';";

	server {
		listen			8080 default;		# listen on HTTP port for ipv4 (avoiding port 80 so we don't need root privs to listen)
#		listen			[::]:8080 default;	# listen on HTTP port for ipv6 (avoiding port 80 so we don't need root privs to listen)
		root			/usr/share/nginx/html/site;
		index			index.php index.html;

		# Allow direct access to this nginx instance only from certain hosts
		allow			127.0.0.0/8;	# Allow from localhost
		allow			172.16.16.20;	# Allow from my SSL terminator
		allow			172.17.0.0/24;	# Allow from Docker containers
		deny			all;

		# Handle PHP appropriately
		location ~ \.php$ {
			try_files $uri =404;
			fastcgi_split_path_info ^(.+\.php)(/.+)$;
#			fastcgi_pass unix:/var/run/php5-fpm.sock; # Debian-based
			fastcgi_pass unix:/run/php-fpm/www.sock; # Fedora-based
			fastcgi_index index.php;
			fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
			include fastcgi_params;
		}

		# Special location blocks
		location /.git { return 418; }
		location /wp-admin { return 418; }
		location /wp-login { return 418; }
		location /install.php { return 418; }
		location /admin { return 418; }
		location /server-status { return 418; }

		# Error pages
		error_page 404 /404/; location = /404/ { }
		error_page 418 /418/; location = /418/ { }
		error_page 500 /500/; location = /500/ { }
		error_page 502 /502/; location = /502/ { }
		error_page 503 /503/; location = /503/ { }
		error_page 504 /504/; location = /504/ { }
	}
}
