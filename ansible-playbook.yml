---
- hosts: all
  name: Configure Terraform Host
  gather_facts: true

  pre_tasks:
    # We need the Cloudflare API keys set in our env vars for this to work, so we will delegate this one task to localhost
    - name: Destroy all previous A records for dns.darkwebkittens.xyz
      cloudflare_dns:
        zone: darkwebkittens.xyz
        record: dns
        type: A
        state: absent
        account_email: "{{ lookup('env','CLOUDFLARE_EMAIL') }}"
        account_api_token: "{{ lookup('env','CLOUDFLARE_API_KEY') }}"
      delegate_to: localhost

    - name: Create a Cloudflare A record for dns.darkwebkittens.xyz with the IP of the AWS machine
      cloudflare_dns:
        zone: darkwebkittens.xyz
        record: dns
        type: A
        # This shouldn't break as Terraform passes the raw IPv4 address of the EC2 instance when handing over to Ansible (not a FQDN/hostname).
        value: '{{ inventory_hostname }}'
        # Short TTL allows for experimentation
        ttl: 300
        account_email: "{{ lookup('env','CLOUDFLARE_EMAIL') }}"
        account_api_token: "{{ lookup('env','CLOUDFLARE_API_KEY') }}"
      delegate_to: localhost

  tasks:
    - name: Update Apt packages
      become: yes
      apt:
        autoremove: yes
        update_cache: yes
        upgrade: full

    - name: Reboot instance after updates
      become: yes
      reboot:

    - name: Wait for it to come back
      wait_for_connection:
        delay: 60
        timeout: 300

    - name: Install Docker & Pip (via Apt)
      become: yes
      apt:
        name:
          - 'docker.io'
          - 'python3-pip'
        state: present

    - name: Install Docker Python API and Docker Compose (via Pip)
      become: yes
      pip:
        name:
          - docker
          - docker-compose
        state: latest

    - name: Copy onion keys and compose file etc. to EC2 instance
      copy:
        src: ~/.ssh/darkwebkittens/
        dest: /home/ubuntu/darkwebkittens/

    - name: Deploy onion service
      become: yes
      docker_compose:
        project_src: /home/ubuntu/darkwebkittens/
        build: yes
        nocache: yes
        recreate: always
        restarted: yes
        state: present

    - name: Pull obfs4-bridge container
      become: yes
      docker_image:
        name: phwinter/obfs4-bridge
        source: pull

    # For obfs4 I'm currently using the default ports for Steam and Minecraft.
    # On AWS this might let us blend in a bit.
    - name: Start obfs4-bridge container
      become: yes
      docker_container:
        name: obfs4-bridge
        image: phwinter/obfs4-bridge
        state: started
        env: "OR_PORT=27015 PT_PORT=25565 EMAIL=alex@alexhaydock.co.uk"

    - name: Create dir to hold acme.sh config
      file:
        path: /home/ubuntu/certs
        state: directory

    - name: Copy acme.sh config (incl. Cloudflare DNS API tokens) to server
      copy:
        src: ~/.ssh/acme_sh_account.conf
        dest: /home/ubuntu/certs/account.conf

    - name: Generate a cert for DoH resolver
      become: yes
      docker_container:
        name: acme.sh
        image: neilpang/acme.sh
        state: started
        auto_remove: yes
        volumes:
          - /home/ubuntu/certs:/acme.sh
        command: "--issue --dns dns_cf -d dns.darkwebkittens.xyz"

    - name: Create cronjob to run at 4 AM to renew cert
      become: yes
      cron:
        name: "Renew cert"
        minute: "0"
        hour: "4"
        job: 'docker run --rm -it -v "/home/ubuntu/certs":"/acme.sh" neilpang/acme.sh --cron'

    # We'll probably also need a cronjob to run after that to reload the Nginx config to actually pick up the new cert if we have one

    - name: Create dir for DoH compose file
      file:
        path: /home/ubuntu/doh
        state: directory

    - name: Copy DoH (Nginx DoH gateway --> Pi-Hole --> cloudflared) Docker Compose file
      copy:
        src: _doh/docker-compose.yml
        dest: /home/ubuntu/doh/docker-compose.yml

    - name: Copy nginx.conf
      copy:
        src: _doh/nginx-public-resolver.conf
        dest: /home/ubuntu/doh/nginx-public-resolver.conf

    - name: Git checkout the Nginx javascript code that translates DoH syntax into what we need (we refer to this in nginx.conf)
      git:
        repo: https://github.com/TuxInvader/nginx-dns.git
        dest: /home/ubuntu/doh/nginx-dns
        clone: yes

    - name: Create dir for Pi-Hole
      file:
        path: /home/ubuntu/pihole/etc-pihole
        state: directory

    - name: Copy my custom Pi-Hole ad list config (the default lists, plus some lists of my own)
      copy:
        src: _doh/adlists.list
        dest: /home/ubuntu/pihole/etc-pihole/adlists.list

    - name: Deploy the Nginx --> Pi-Hole --> cloudflared stack with Docker Compose
      become: yes
      docker_compose:
        project_src: /home/ubuntu/doh/
        build: yes
        nocache: yes
        recreate: always
        restarted: yes
        state: present

    - name: Read the obfs4 relay hash from the running container
      become: yes
      command: docker exec -i obfs4-bridge cat /var/lib/tor/hashed-fingerprint
      register: obfs4_hash

    - name: Read the onion service address from the running container
      become: yes
      command: docker exec -i kittens-tor cat /opt/onion/hostname
      register: onion_hostname

    - debug:
        msg: "âœ… Your new DoH instance is available at https://dns.darkwebkittens.xyz/dns-query"

    - debug:
        msg: "ðŸ§… The onion service should also be available at http://{{ onion_hostname.stdout }}"

    - debug:
        msg: "ðŸ§… Your obfs4 bridge's name and fingerprint are: {{ obfs4_hash.stdout }}. After a few hours your bridge should be visible with this hash on: https://metrics.torproject.org"
...
